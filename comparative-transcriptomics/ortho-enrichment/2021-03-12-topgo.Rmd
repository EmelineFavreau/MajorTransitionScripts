---
title: "TopGo analyses"
author: "Emeline Favreau"
date: "2021/03/12"
output: html_document
---

Copyright 2021 Emeline Favreau, University College London.

##### Objective of analysis
Understanding TopGo by testing _Ceratina australensis_ dataset of differentially expressed genes that are upregulated in reproductives.

##### Analysis steps:
- Obtaining data
- Aim 1: GO term enrichment (BP) c.austra DEG up Queen



```{r load all the libraries, eval = TRUE, echo = FALSE, include = FALSE}
# get libraries
basic_libraries <- c("ggplot2",
                     "readr")

# install and/or load
for (lib in basic_libraries) {
        if (require(package = lib, character.only = TRUE)) {
                print("Successful")
        } else {
                print("Installing")
                install.packages(lib)
                library(lib, character.only = TRUE )
        }
}

#install.packages("BiocManager")
#BiocManager::install("topGO")
#BiocManager::install("biomaRt")
library(topGO)
library("biomaRt")
```


```{r import data, eval = TRUE, echo = FALSE, include = FALSE}
# import orthofinder results
# columns: orthogroups, and names of species
#Orthogroups <- read_table2("inputOnScratch/Orthogroups.tsv")


# import all DEG results for ceratina australensis
# columns: X baseMean log2FoldChange lfcSE stat pvalue padj
# rows: genes
Ceratina_australensis_DESeq2_results <- read.delim("inputOnScratch/Ceratina_australensis_DESeq2_results.txt",
                                             stringsAsFactors = FALSE)

# import DEG upregulated in reproductives
# one column with names of genes
Ceratina_australensis_upR_DEGs <- read.table("inputOnScratch/Ceratina_australensis_upR_DEGs.txt",
                                             quote = "\"",
                                             comment.char = "",
                                             stringsAsFactors = FALSE)

      
# blast results: each Drosophila Orthogroup has a match in similarity with a species' protein
blast_results_austra <- read.table("resultOnScratch/Ceratina_australensis_filtered",
                                    stringsAsFactors = FALSE)
```

```{r set species data input, eval = TRUE, echo = FALSE, include = FALSE}

# set experiment details (species, upregulated in Reproductives or NonReproductives)
this_species <- "Ceratina_australensis"
this_data_subset <- "R"
this_goCategory <- "BP"

# set species data input
raw_results         <- Ceratina_australensis_DESeq2_results
raw_selectionGenes  <- Ceratina_australensis_upR_DEGs
raw_blast_results   <- blast_results_austra

# add column names 
colnames(raw_results) <- c("gene", colnames(raw_results)[2:7])
colnames(raw_selectionGenes) <- "gene"
colnames(raw_blast_results) <- c("qseqid", "sseqid", "pident", "length",
                                    "mismatch", "gapopen", "qstart",
                                    "qend", "sstart", "send", "evalue",
                                    "bitscore")


```


```{r getting gene to go mapping droso, eval = TRUE, echo = FALSE, include = FALSE}
# https://www.bioconductor.org/packages/devel/bioc/vignettes/biomaRt/inst/doc/accessing_ensembl.html#introduction

# the first time around do this
# ensembl <- useEnsembl(biomart = "ensembl")
# find droso
# dmelanogaster_gene_ensembl	Drosophila melanogaster genes (BDGP6.32)	BDGP6.32
# datasets <- listDatasets(ensembl)

# the following instances, just run this
# connect to the genes services
ensembl <- useEnsembl(biomart = "ensembl",
                      dataset = "dmelanogaster_gene_ensembl")


# searchAttributes(mart = ensembl, pattern = "FlyBase")
# searchAttributes(mart = ensembl, pattern = "goslim")
# we want flybase_translation_id
# our droso gene name come from ensembl under name FlyBase translation

# list of droso genes that I want, I think these are transcript id
droso_gene_list <- raw_blast_results$sseqid

# ideally we'd like to update r to version 4.0.03 and bioconductor to 3.12
# https://support.bioconductor.org/p/p132704/#p132714
# https://support.bioconductor.org/p/p132709/#p133220
# but we can go around the issue with useCache = FALSE
gene2Go_raw <- getBM(attributes = c("flybase_translation_id", "go_id"), 
              filters     = "flybase_translation_id", 
              values      = droso_gene_list, 
              mart        = ensembl,
              useCache    = FALSE)

# testing retrival of slim terms (not so sure what I am doing)
gene2Go_raw_slim <- getBM(attributes = c("flybase_translation_id", "goslim_goa_accession"), 
              filters     = "flybase_translation_id", 
              values      = droso_gene_list, 
              mart        = ensembl,
              useCache    = FALSE)


# Remove the genes without GO terms
gene2Go_df_slim <- subset(x = gene2Go_raw_slim,
                     subset = !goslim_goa_accession == "")

# Remove the genes without GO terms
gene2Go_df <- subset(x = gene2Go_raw,
                     subset = !go_id == "")

# update the object to fit topgo
gene_to_go <- aggregate(go_id ~ flybase_translation_id,
                        data = gene2Go_df,
                        c)

# update the object to fit topgo
gene_to_go_slim <- aggregate(goslim_goa_accession ~ flybase_translation_id,
                        data = gene2Go_df_slim,
                        c)

# vector of GO identifiers
go_id <- gene_to_go$go_id

# vector of GO identifiers
go_id_slim <- gene_to_go_slim$goslim_goa_accession

# add names to the vector
gene2go <- setNames(go_id,
                    gene_to_go$flybase_translation_id)

# add names to the vector
gene2go_slim <- setNames(go_id_slim,
                    gene_to_go_slim$flybase_translation_id)


```

##### Aim 1: GO term enrichment (BP) c.austra DEG up Queen 

```{r aim 1 test for GO term enrichment austra DEG up Queen, eval = TRUE, echo = FALSE, include = FALSE}

# aim to change species's protein names for drosophila names
# because the TopGO database does not contain non-model data
raw_results$droso_gene <- raw_blast_results$sseqid[match(raw_results$gene,
                                                         raw_blast_results$qseqid)]

raw_selectionGenes$droso_gene <- raw_blast_results$sseqid[match(raw_selectionGenes$gene,
                                                         raw_blast_results$qseqid)]



## make a vector with 0 or 1 values depending if a gene is DE or not
# results: lists of genes differentially expressed 
geneList <- rep(0, times = length(rownames(raw_results)))

# name each value with the droso genes names
names(geneList) <- raw_results$droso_gene

# selectionGenes: list of DEG for selection
DEGenes <- raw_selectionGenes$droso_gene

# for each gene that is the focus of the analysis, change the value 0 for 1
geneList[DEGenes] <- 1

# change the class to factor
geneList <-  as.factor(geneList)


## Build the topGO object for biological process ontology
# GO section; Biological process
# gene environment: geneList
# gene selection: factored list of genes that are under study (here upregulated)
# remove terms that have less than 5 annotated genes
# function annFUN.gene2GO used when the annotations are provided as a gene-to-GOs mapping
# gene2Go file has droso gene identifiers and GO
this_topGOdata <- new("topGOdata",
              ontology = this_goCategory,
              allGenes = geneList,
              geneSel  = DEGenes,
              nodeSize = 5,
              annot    = annFUN.gene2GO,
              gene2GO  = gene2go)

this_topGOdata_slim <- new("topGOdata",
              ontology = this_goCategory,
              allGenes = geneList,
              geneSel  = DEGenes,
              nodeSize = 5,
              annot    = annFUN.gene2GO,
              gene2GO  = gene2go_slim)

# test for enrichment
# because we coded the genes 1 or 0 for DEG presence or absence, Fisher test (gene count) is probably the best algorithm
# classic: each GO category is tested independently
this_topGOresult <- runTest(this_topGOdata,
                    algorithm = "classic",
                    statistic = "fisher")

this_topGOresult_slim <- runTest(this_topGOdata_slim,
                    algorithm = "classic",
                    statistic = "fisher")

#this_topGOresult

# create a result table
# GO Terms identified by fisher test
# 4170: the number of top GO terms to be included in the table.
myTable <- GenTable(this_topGOdata,
                    pvalue = this_topGOresult,
                    topNodes = length(this_topGOdata@graph@nodes),
                    numChar = 100)

myTable_slim <- GenTable(this_topGOdata_slim,
                    pvalue = this_topGOresult_slim,
                    topNodes = length(this_topGOdata_slim@graph@nodes),
                    numChar = 100)


# add columns to specify test details
myTable$species <- this_species
myTable$dataSubset <- this_data_subset
myTable$goCategory <- this_goCategory

```

```{r present results, eval = TRUE, echo = FALSE, include = TRUE}
# check the first top hits
head(myTable)

# get the pvalues (named vector)
pvalues <- score(this_topGOresult)
# length(pvalues[pvalues<0.05])

# make a file name
this_file_name <- paste("resultOnScratch/topgo_result",
                        this_species,
                        this_data_subset,
                        this_goCategory,
                        sep = "_")
# save table
write.table(x          = myTable,
            file       = this_file_name,
            quote      = FALSE,
            row.names  = FALSE,
            sep        = "\t")
```

*Conclusion*

161 GO terms that are enriched in C.australensis DEG dataset (upregulated in reproductives)

I will run this script for all 6 species, 2 datasets (R and NR), 3 GO categories (BP, MF and CC)

```{r simple bar chart, eval = TRUE, echo = FALSE, include = FALSE}

library(ggplot2)
library(tidyverse)

# subset for the important data - here we make up data
australensis_table <- myTable %>% filter(pvalue < 0.05) %>%
  select(GO.ID, species, Term)

dominula_table <- myTable[1:50,] %>% filter(pvalue < 0.05) %>%
  select(GO.ID, species, Term)
dominula_table$species <- "Polistes_dominula"

genalis_table <- myTable[40:3009, ] %>% filter(pvalue < 0.05) %>%
  select(GO.ID, species, Term)
genalis_table$species <- "Megalopta_genalis"

canadensis_table <- myTable[1:78,] %>% filter(pvalue < 0.05) %>%
  select(GO.ID, species, Term)
canadensis_table$species <- "Polistes_canadensis"

calcarata_table <- myTable[67:3009, ] %>% filter(pvalue < 0.05) %>%
  select(GO.ID, species, Term)
calcarata_table$species <- "Ceratina_calcarata"

flavolineata_table <- myTable[3:33, ] %>% filter(pvalue < 0.05) %>%
  select(GO.ID, species, Term)
flavolineata_table$species <- "Liostenogaster_flavolineata"

# obtain vector of all GO 
GO.ID <- unique(c(australensis_table$GO.ID,
                  dominula_table$GO.ID,
                  genalis_table$GO.ID,
                  canadensis_table$GO.ID,
                  calcarata_table$GO.ID,
                  flavolineata_table$GO.ID))

# # combine the info
# # for each GO term, calculate the presence in species dataset
# result_table <- as.data.frame(matrix(nrow = length(GO.ID),
#                                      ncol = 2),
#                               stringsAsFactors = FALSE)
# 
# colnames(result_table) <- c("GO.ID", "species_number")
# 
# # the first column has all GO ids
# result_table$GO.ID <- GO.ID
# 
# 
# # the second column has the number of species with GO present in dataset
# for(i in 1:nrow(result_table)){
#   result_table$species_number[i] <- sum(result_table$GO.ID[i] %in% Ceratina_table$GO.ID,
#     result_table$GO.ID[i] %in% Polistes_table$GO.ID,
#     result_table$GO.ID[i] %in% Megalopta_table$GO.ID)
# }
# 
# str(result_table)
# summary(result_table$species_number)
# 
# 
# 
# # Basic barplot
# ggplot(data = result_table,
#        aes(x = GO.ID, y = species_number)) +
#   geom_bar(stat = "identity") + coord_flip()
# 
   


```

```{r stacked bar chart, eval = TRUE, echo = FALSE, include = FALSE}
# https://ggplot2.tidyverse.org/reference/geom_bar.html

# make a new table
# columns: GOID, Terms, species
stacked_result <- rbind(australensis_table,
                  dominula_table,
                  genalis_table,
                  canadensis_table,
                  calcarata_table,
                  flavolineata_table)

# add a Freq column
stacked_result$Freq <- 0

# populate Frequency column
for(i in 1:nrow(stacked_result)){
  # subset for one go term
  this_go_df <- stacked_result %>%filter(GO.ID == GO.ID[i])
  
  # calculate frequency and add to the column
  stacked_result$Freq[i] <- nrow(this_go_df)
}

# reorder dataset by decreasing Freq
stacked_result_reordered <- stacked_result[order(stacked_result$Freq,
                                                 decreasing = T), ]

# applying factor to Freq column, to order the x axis in the following plot
stacked_result_reordered$Freq <- factor(stacked_result_reordered$Freq,
                                       ordered = TRUE)

# this bar plot is for all results (Frequency of 2 or more)
ggplot(subset(stacked_result_reordered,
              subset = stacked_result_reordered$Freq %in% c("3", "4")),
       aes(y = Term)) +
 geom_bar(aes(fill = species),
          position = position_stack(reverse = TRUE)) +
 theme(legend.position = "top") +
  theme(axis.text = element_text(size = 8)) +
  scale_x_discrete(limits = c("1","2","3", "4"))






```

```{r stacked bar chart wasp only, eval = TRUE, echo = FALSE, include = FALSE}
# name the species of wasps
wasp <- c("Polistes_canadensis",
          "Polistes_dominula",
          "Liostenogaster_flavolineata")

# subset the data for wasps
wasp_stacked_result <- stacked_result %>%filter(species == wasp)  

# this bar plot is for wasp only
ggplot(wasp_stacked_result, aes(y = Term)) +
 geom_bar(aes(fill = species),
          position = position_stack(reverse = TRUE)) +
 theme(legend.position = "top") + 
  scale_x_discrete(limits = c("1","2","3"))


```

```{r stacked bar chart bee only, eval = TRUE, echo = FALSE, include = FALSE}
# name the species of bees
bee <- c("Ceratina_australensis",
          "Ceratina_calcarata" ,
          "Megalopta_genalis")

# subset the data for wasps
bee_stacked_result <- stacked_result %>% filter(species == bee)  

# this bar plot is for bee only
ggplot(bee_stacked_result, aes(y = Term)) +
 geom_bar(aes(fill = species),
          position = position_stack(reverse = TRUE)) +
 theme(legend.position = "top") + 
  scale_x_discrete(limits = c("1","2","3"))


```

```{r record versions of session, eval = TRUE, echo = FALSE, include = FALSE}
# record versions of R and packages here
sessionInfo()
# R version 3.6.3 (2020-02-29)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Catalina 10.15.4
# 
# Matrix products: default
# BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
# LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
# 
# locale:
# [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8
# 
# attached base packages:
# [1] stats     graphics  grDevices utils     datasets  methods   base     
# 
# other attached packages:
# [1] forcats_0.5.0   stringr_1.4.0   dplyr_0.8.5     purrr_0.3.4     readr_1.3.1    
# [6] tidyr_1.0.3     tibble_3.0.1    tidyverse_1.3.0 ggplot2_3.3.0  
# loaded via a namespace (and not attached):
#  [1] Rcpp_1.0.4.6     cellranger_1.1.0 pillar_1.4.4     compiler_3.6.3   dbplyr_1.4.3    
#  [6] tools_3.6.3      lubridate_1.7.8  jsonlite_1.6.1   lifecycle_0.2.0  gtable_0.3.0    
# [11] nlme_3.1-147     lattice_0.20-41  pkgconfig_2.0.3  rlang_0.4.6      reprex_0.3.0    
# [16] cli_2.0.2        DBI_1.1.0        rstudioapi_0.11  yaml_2.2.1       haven_2.2.0     
# [21] xfun_0.13        xml2_1.3.2       withr_2.2.0      httr_1.4.1       knitr_1.28      
# [26] fs_1.4.1         generics_0.0.2   vctrs_0.3.0      hms_0.5.3        grid_3.6.3      
# [31] tidyselect_1.1.0 glue_1.4.1       R6_2.4.1         fansi_0.4.1      readxl_1.3.1    
# [36] modelr_0.1.7     magrittr_1.5     scales_1.1.1     backports_1.1.7  ellipsis_0.3.0  
# [41] rvest_0.3.5      assertthat_0.2.1 colorspace_1.4-1 stringi_1.4.6    munsell_0.5.0   
# [46] broom_0.5.6      crayon_1.3.4 
```
```{r draft, eval = FALSE, echo = FALSE, include = FALSE}
# # carlos code
# #Get the Ensembl info from S.invicta
# metazoa_mart <- useMart(biomart = "metazoa_mart",
#                         dataset = "sinvicta_eg_gene",
#                         host = "metazoa.ensembl.org")
# #Select the gene names, its associated GO terms and the names of these GO terms
# gene_to_go <- getBM(attributes = c("ensembl_gene_id", "go_id", "name_1006"),
#                     mart = metazoa_mart)
# #Remove the genes without GO terms
# gene_to_go <- subset(x = gene_to_go,
#                      subset = !go_id == "")
# #Parse the data frame to adapt it to the topGO format (named list of character vectors. The list names are genes identifiers. For eachgene the character vector contains the GO identifiers it maps to).
# gene_to_go <- aggregate(go_id ~ ensembl_gene_id, data = gene_to_go, c)
# go_id <- gene_to_go$go_id
# gene2go <- setNames(go_id, gene_to_go$ensembl_gene_id)
# #Generate a TopGO object
# all_genes <- factor(as.integer(unique(tx_gene$gene)))
# names(all_genes) <- unique(tx_gene$gene)
# go_data <- new("topGOdata", ontology = "BP", allGenes = all_genes,
#                  annot = annFUN.gene2GO, gene2GO = gene2go)
# 
# ##############################################################################
# # federico code
# biomaRt::listMarts(host = "metazoa.ensembl.org")
# 
# dmel_mart <- biomaRt::useEnsembl(
#   biomart = "metazoa_mart",
#   dataset = "dmelanogaster_eg_gene",
#   host = "metazoa.ensembl.org"
# )
# 
# dmel_tx2gene <- biomaRt::getBM(
#   attributes = c("ensembl_transcript_id", "ensembl_gene_id"),
#   mart = dmel_mart
# )
```