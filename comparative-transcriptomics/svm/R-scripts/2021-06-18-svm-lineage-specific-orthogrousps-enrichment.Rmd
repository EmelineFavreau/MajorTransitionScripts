---
title: "SVM result analysis: lineage-specific orthogroups"
author: "Emeline Favreau"
date: "2021-06-18"
output: html_document
---

Copyright 2021 Emeline Favreau, University College London.

Read count from reproductives and non-reproductives were input to SVM to classify samples based on the gene expression pattern. Six SVM models were run, each with a different species as test data.
The bees were tested on bees, using 5,787 bee orthogroups.
The wasps were tested on wasps, using 6,983 wasp orthogroups.

Here we compare predictor genes between species: is there an overlap between species? among/between lineages?

---
# Objective of analysis

## Analysis steps:
- Obtaining data
- Aim 1: describe overlap between SVM predictor genes
- Aim 2: GO Terms associated with those predictor genes
- Aim 3: GO Terms associated for each species
- Aim 4: description



```{r load all the libraries, eval = TRUE, echo = FALSE, include = FALSE}
# get libraries
basic_libraries <- c("ggplot2",
                     "tidyverse")

for (lib in basic_libraries) {
        if (require(package = lib, character.only = TRUE)) {
                print("Successful")
        } else {
                print("Installing")
                install.packages(lib)
                library(lib, character.only = TRUE )
        }
}
```


```{r import data, eval = TRUE, echo = FALSE, include = FALSE}
# list of predicted genes in C.aus
# obtained by SVM 
Ceratina_australensis_svm_gene <- read.table("result/regression-on-bee-orthologs/Ceratina_australensis_Caus_bee_regression_predicted_gene_list_tidy",
           quote="\"",
           comment.char="", stringsAsFactors = FALSE)

# list of predicted genes in C.cal
Ceratina_calcarata_svm_gene <- read.table("result/regression-on-bee-orthologs/Ceratina_calcarata_Ccal_bee_regression_predicted_gene_list_tidy",
           quote="\"",
           comment.char="", stringsAsFactors = FALSE)

# list of predicted genes in M.gen
# obtained by SVM 
Megalopta_genalis_svm_gene <- read.table("result/regression-on-bee-orthologs/Megalopta_genalis_Mgen_bee_regression_predicted_gene_list_tidy",
           quote="\"",
           comment.char="", stringsAsFactors = FALSE)

# list of predicted genes in Pdom
Polistes_dominula_svm_gene <- read.table("result/regression-on-wasp-orthologs/Polistes_dominula_Pdom_wasp_regression_predicted_gene_list_tidy",
           quote="\"",
           comment.char="", stringsAsFactors = FALSE)

# list of predicted genes in LF
# obtained by SVM 
Liostenogaster_flavolineata_svm_gene <- read.table("result/regression-on-wasp-orthologs//Liostenogaster_flavolineata_Lfla_wasp_regression_predicted_gene_list_tidy",
           quote="\"",
           comment.char="", stringsAsFactors = FALSE)

# list of predicted genes in Pcan
Polistes_canadensis_svm_gene <- read.table("result/regression-on-wasp-orthologs/Polistes_canadensis_Pcan_wasp_regression_predicted_gene_list_tidy",
           quote="\"",
           comment.char="", stringsAsFactors = FALSE)



```

## Aim 1: describe overlap between SVM predictor genes

```{r aim 1, eval = TRUE, echo = FALSE, include = TRUE}
# the groups that we are testing
all_species <- c("Polistes_canadensis",
          "Polistes_dominula",
          "Liostenogaster_flavolineata",
          "Ceratina_australensis",
          "Ceratina_calcarata" ,
          "Megalopta_genalis")

wasp <- c("Polistes_canadensis",
          "Polistes_dominula",
          "Liostenogaster_flavolineata")

bee <- c("Ceratina_australensis",
          "Ceratina_calcarata" ,
          "Megalopta_genalis")

# add column names
colnames(Ceratina_australensis_svm_gene) <- "predictor_gene"
colnames(Polistes_dominula_svm_gene) <- "predictor_gene"
colnames(Megalopta_genalis_svm_gene) <- "predictor_gene"
colnames(Polistes_canadensis_svm_gene) <- "predictor_gene"
colnames(Ceratina_calcarata_svm_gene) <- "predictor_gene"
colnames(Liostenogaster_flavolineata_svm_gene) <- "predictor_gene"

# add species column 
Ceratina_australensis_svm_gene$species <- "Ceratina_australensis"
Polistes_dominula_svm_gene$species <- "Polistes_dominula"
Megalopta_genalis_svm_gene$species <- "Megalopta_genalis"
Polistes_canadensis_svm_gene$species <- "Polistes_canadensis"
Ceratina_calcarata_svm_gene$species <- "Ceratina_calcarata"
Liostenogaster_flavolineata_svm_gene$species <- "Liostenogaster_flavolineata"

# obtain vector of all wasp genes
wasp_predictor_genes_vec <- unique(c(Polistes_dominula_svm_gene$predictor_gene,
                     Polistes_canadensis_svm_gene$predictor_gene,
                     Liostenogaster_flavolineata_svm_gene$predictor_gene))

bee_predictor_genes_vec <- unique(c(Ceratina_australensis_svm_gene$predictor_gene,
                     Megalopta_genalis_svm_gene$predictor_gene,
                     Ceratina_calcarata_svm_gene$predictor_gene))


# make a new wasp table
# predictor genes | Species 1 | Species 2 | Species 3 | 
wasp_wide_df <- as.data.frame(matrix(NA, nrow = length(wasp_predictor_genes_vec ),
                                ncol = 4))

bee_wide_df <- as.data.frame(matrix(NA, nrow = length(bee_predictor_genes_vec ),
                                ncol = 4))
# name the columns
colnames(wasp_wide_df) <- c("predictor_gene",
                       wasp)

colnames(bee_wide_df) <- c("predictor_gene",
                       bee)

# assign predictor genes
wasp_wide_df$predictor_gene <- wasp_predictor_genes_vec
bee_wide_df$predictor_gene <- bee_predictor_genes_vec

# set all species column count to 0
wasp_wide_df$Polistes_canadensis         <- 0
wasp_wide_df$Polistes_dominula           <- 0
wasp_wide_df$Liostenogaster_flavolineata <- 0
bee_wide_df$Ceratina_australensis       <- 0
bee_wide_df$Ceratina_calcarata          <- 0
bee_wide_df$Megalopta_genalis           <- 0


# make a new table
# columns: gene, species
wasp_stacked_result <- rbind(Polistes_dominula_svm_gene,
                     Polistes_canadensis_svm_gene,
                     Liostenogaster_flavolineata_svm_gene)

bee_stacked_result <- rbind(Ceratina_australensis_svm_gene,
                     Megalopta_genalis_svm_gene,
                     Ceratina_calcarata_svm_gene)


# fill info for wasp
for(i in wasp_predictor_genes_vec){
  
  # subset data for a given gene
  this_subset <- wasp_stacked_result %>% filter(predictor_gene == i)
  
  # assign 1 if present in this species
  
  if("Polistes_canadensis" %in% this_subset$species){
    wasp_wide_df$Polistes_canadensis[wasp_wide_df$predictor_gene == i] <- 1
  }
  
  if("Polistes_dominula" %in% this_subset$species){
    wasp_wide_df$Polistes_dominula[wasp_wide_df$predictor_gene == i] <- 1
  }
  
  if("Liostenogaster_flavolineata" %in% this_subset$species){
    wasp_wide_df$Liostenogaster_flavolineata[wasp_wide_df$predictor_gene == i] <- 1
  }
  
  
}

# fill info for wasp
for(i in bee_predictor_genes_vec){
  
  # subset data for a given gene
  this_subset <- bee_stacked_result %>% filter(predictor_gene == i)
  
  # assign 1 if present in this species
  if("Ceratina_australensis" %in% this_subset$species){
    bee_wide_df$Ceratina_australensis[bee_wide_df$predictor_gene == i] <- 1
  }
  
  if("Ceratina_calcarata" %in% this_subset$species){
    bee_wide_df$Ceratina_calcarata[bee_wide_df$predictor_gene == i] <- 1
  }
  
  if("Megalopta_genalis" %in% this_subset$species){
   bee_wide_df$Megalopta_genalis[bee_wide_df$predictor_gene == i] <- 1
  }
}

# add a column with count of species that have that gene
wasp_wide_df$species_count <- wasp_wide_df %>%
  select(all_of(wasp)) %>%
  rowSums()

bee_wide_df$species_count <- bee_wide_df %>%
  select(all_of(bee)) %>%
  rowSums()

# list genes that are common to all wasps: 16 genes
# wasp_wide_df %>% filter(species_count == 3) %>%  nrow()
# bee_wide_df %>% filter(species_count == 3) %>%  nrow()
common_wasp_predictor_genes <- wasp_wide_df %>% 
  filter(species_count == 3)  %>%
  select(predictor_gene)

common_bee_predictor_genes <- bee_wide_df %>% 
  filter(species_count == 3)  %>%
  select(predictor_gene)

# save those genes to explore GO Terms and literature review
write.table(x = common_wasp_predictor_genes,
            file = "result/regression-on-wasp-orthologs/20_common_wasp_predictor_genes",
            quote = FALSE,
            row.names = FALSE)

write.table(x = common_bee_predictor_genes,
            file = "result/regression-on-bee-orthologs/16_common_bee_predictor_genes",
            quote = FALSE,
            row.names = FALSE)
  

```

There are 20 predictor genes that are common to all wasps.
There are 16 predictor genes that are common to all bees.

## Aim 2: GO Terms associated with those predictor genes

```{r aim 2, eval = FALSE, echo = FALSE, include = FALSE}
# obtain GO Terms associated with the predictor genes
# all_predictor_genes_vec
library("biomaRt")
library("topGO")
                     

# vector of all categories available
goCategory_vec <- c("BP", "MF", "CC")

# loop over the categories
for(gocat in goCategory_vec){

      # set experiment details (species, GO Category)
      this_goCategory  <- gocat
      
      # set data input
      raw_results_file         <- "input/Ceratina_australensis_5787_gene_orthogroups_list" 
      raw_selectionGenes_file  <- "result/regression-on-bee-orthologs/16_common_bee_predictor_genes"
      raw_blast_results_file   <- "../ortho-enrichment/resultOnScratch/Ceratina_australensis_filtered"
      hash_table <- "../ortho-enrichment/tmp/Ceratina_australensis_protein_gene_hash_table"
      
      
      # import all orthogroups
      # columns: orthogroup, gene name
      raw_results <- read.delim(raw_results_file,
                                stringsAsFactors = FALSE, header = FALSE)
      
      # import predictor genes
      # one column with names of orthogroups
      raw_selectionGenes <- read.delim(raw_selectionGenes_file,
                                stringsAsFactors = FALSE, header = TRUE)
      
      
      # blast results: each Drosophila Orthogroup has a match in similarity with a species' protein
      raw_blast_results <- read.table(raw_blast_results_file,
                                      stringsAsFactors = FALSE)
      
      # hash table: protein in column 1, gene in column 2
      hash_df <- read.table(hash_table,
                            stringsAsFactors = FALSE)
      
      # add column names 
      colnames(raw_results) <- c("orthogroup", "gene")
      colnames(raw_selectionGenes) <- "orthogroup"
      colnames(raw_blast_results) <- c("qseqid", "sseqid", "pident", "length",
                                       "mismatch", "gapopen", "qstart",
                                       "qend", "sstart", "send", "evalue",
                                       "bitscore")
      
      colnames(hash_df) <- c("qseqid", "gene")
      
      # add a colum for gene
      raw_selectionGenes$gene <- raw_results$gene[match(raw_selectionGenes$orthogroup,
                                                        raw_results$orthogroup)]
      
      # update blast query sequence id (to gene-LOCXXX, matching DESeq2 result table)
      raw_blast_results$qseqid <- hash_df$gene[match(raw_blast_results$qseqid,
                                                     hash_df$qseqid)]
    
      
      # connect to the genes services
      ensembl <- useEnsembl(biomart = "ensembl",
                            dataset = "dmelanogaster_gene_ensembl")
      
      
      
      # list of droso genes transcript id
      droso_gene_list <- raw_blast_results$sseqid
      
      # obtain GO terms for these genes (they match to our species)
      gene2Go_raw <- getBM(attributes = c("flybase_translation_id", "go_id"), 
                           filters     = "flybase_translation_id", 
                           values      = droso_gene_list, 
                           mart        = ensembl,
                           useCache    = FALSE)
      
      # Remove the genes without GO terms
      gene2Go_df <- subset(x = gene2Go_raw,
                           subset = !go_id == "")
      
      # update the object to fit topgo
      gene_to_go <- aggregate(go_id ~ flybase_translation_id,
                              data = gene2Go_df,
                              c)
      # vector of GO identifiers
      go_id <- gene_to_go$go_id
      
      # add names to the vector
      gene2go <- setNames(go_id,
                          gene_to_go$flybase_translation_id)
      
      ##### GO term enrichment 
      
      # aim to change species's protein names for drosophila names
      # because the TopGO database does not contain non-model data
      # there are NA because blasting droso against the species might have produced no hit
      raw_results$droso_gene <- raw_blast_results$sseqid[match(raw_results$gene,
                                                               raw_blast_results$qseqid)]
      
      raw_selectionGenes$droso_gene <- raw_blast_results$sseqid[match(raw_selectionGenes$gene,
                                                                      raw_blast_results$qseqid)]
      
      
      # remove NA. 
      raw_results <- raw_results[!is.na(raw_results$droso_gene), ]
      raw_selectionGenes <- raw_selectionGenes[!is.na(raw_selectionGenes$droso_gene), ]
      
      
      ## make a vector with 0 or 1 values depending if a gene is predictor or not
      # results: lists of predictor genes 
      geneList <- rep(0, times = length(rownames(raw_results)))
      
      # name each value with the droso genes names
      names(geneList) <- raw_results$droso_gene
      
      # selectionGenes: list of predictor genes  for selection
      PredictorGenes <- raw_selectionGenes$droso_gene
      
      # for each gene that is the focus of the analysis, change the value 0 for 1
      geneList[PredictorGenes] <- 1
      
      # change the class to factor
      geneList <-  as.factor(geneList)
      
      ## Build the topGO object for biological process ontology
      this_topGOdata <- new("topGOdata",
                            ontology = this_goCategory,
                            allGenes = geneList,
                            geneSel  = PredictorGenes,
                            nodeSize = 5,
                            annot    = annFUN.gene2GO,
                            gene2GO  = gene2go)
      
      # test for enrichment
      # because we coded the genes 1 or 0 for Predictor gene presence or absence,
      # Fisher test (gene count) is probably the best algorithm
      # classic: each GO category is tested independently
      this_topGOresult <- runTest(this_topGOdata,
                                  algorithm = "classic",
                                  statistic = "fisher")
      
      
      
      # create a result table
      # GO Terms identified by fisher test
      myTable <- GenTable(this_topGOdata,
                          pvalue = this_topGOresult,
                          topNodes = length(this_topGOdata@graph@nodes),
                          numChar = 100)
      
      
      # add columns to specify test details
      myTable$species    <- "common to all"
      myTable$goCategory <- this_goCategory
      
      # make a file name
      this_file_name <- paste("result/regression-on-bee-orthologs/topgo_result",
                              "common-to-all-bees",
                              this_goCategory,
                              sep = "_")
      # save table
      write.table(x          = myTable,
                  file       = this_file_name,
                  quote      = FALSE,
                  row.names  = FALSE,
                  sep        = "\t")
      
}   
    
# wasp 
# loop over the categories
for(gocat in goCategory_vec){

      # set experiment details (species, GO Category)
      this_goCategory  <- gocat
      
      # set data input
      raw_results_file         <- "input/Polistes_canadensis_6983_gene_orthogroups_list" 
      raw_selectionGenes_file  <- "result/regression-on-wasp-orthologs/20_common_wasp_predictor_genes"
      raw_blast_results_file   <- "../ortho-enrichment/resultOnScratch/Polistes_canadensis_filtered"
      hash_table <- "../ortho-enrichment/tmp/Polistes_canadensis_protein_gene_hash_table"
      
      
      # import all orthogroups
      # columns: orthogroup, gene name
      raw_results <- read.delim(raw_results_file,
                                stringsAsFactors = FALSE, header = FALSE)
      
      # import predictor genes
      # one column with names of orthogroups
      raw_selectionGenes <- read.delim(raw_selectionGenes_file,
                                stringsAsFactors = FALSE, header = TRUE)
      
      
      # blast results: each Drosophila Orthogroup has a match in similarity with a species' protein
      raw_blast_results <- read.table(raw_blast_results_file,
                                      stringsAsFactors = FALSE)
      
      # hash table: protein in column 1, gene in column 2
      hash_df <- read.table(hash_table,
                            stringsAsFactors = FALSE)
      
      # add column names 
      colnames(raw_results) <- c("orthogroup", "gene")
      colnames(raw_selectionGenes) <- "orthogroup"
      colnames(raw_blast_results) <- c("qseqid", "sseqid", "pident", "length",
                                       "mismatch", "gapopen", "qstart",
                                       "qend", "sstart", "send", "evalue",
                                       "bitscore")
      
      colnames(hash_df) <- c("qseqid", "gene")
      
      # add a colum for gene
      raw_selectionGenes$gene <- raw_results$gene[match(raw_selectionGenes$orthogroup,
                                                        raw_results$orthogroup)]
      
      # update blast query sequence id (to gene-LOCXXX, matching DESeq2 result table)
      raw_blast_results$qseqid <- hash_df$gene[match(raw_blast_results$qseqid,
                                                     hash_df$qseqid)]
    
      
      # connect to the genes services
      ensembl <- useEnsembl(biomart = "ensembl",
                            dataset = "dmelanogaster_gene_ensembl")
      
      
      
      # list of droso genes transcript id
      droso_gene_list <- raw_blast_results$sseqid
      
      # obtain GO terms for these genes (they match to our species)
      gene2Go_raw <- getBM(attributes = c("flybase_translation_id", "go_id"), 
                           filters     = "flybase_translation_id", 
                           values      = droso_gene_list, 
                           mart        = ensembl,
                           useCache    = FALSE)
      
      # Remove the genes without GO terms
      gene2Go_df <- subset(x = gene2Go_raw,
                           subset = !go_id == "")
      
      # update the object to fit topgo
      gene_to_go <- aggregate(go_id ~ flybase_translation_id,
                              data = gene2Go_df,
                              c)
      # vector of GO identifiers
      go_id <- gene_to_go$go_id
      
      # add names to the vector
      gene2go <- setNames(go_id,
                          gene_to_go$flybase_translation_id)
      
      ##### GO term enrichment 
      
      # aim to change species's protein names for drosophila names
      # because the TopGO database does not contain non-model data
      # there are NA because blasting droso against the species might have produced no hit
      raw_results$droso_gene <- raw_blast_results$sseqid[match(raw_results$gene,
                                                               raw_blast_results$qseqid)]
      
      raw_selectionGenes$droso_gene <- raw_blast_results$sseqid[match(raw_selectionGenes$gene,
                                                                      raw_blast_results$qseqid)]
      
      
      # remove NA. 
      raw_results <- raw_results[!is.na(raw_results$droso_gene), ]
      raw_selectionGenes <- raw_selectionGenes[!is.na(raw_selectionGenes$droso_gene), ]
      
      
      ## make a vector with 0 or 1 values depending if a gene is predictor or not
      # results: lists of predictor genes 
      geneList <- rep(0, times = length(rownames(raw_results)))
      
      # name each value with the droso genes names
      names(geneList) <- raw_results$droso_gene
      
      # selectionGenes: list of predictor genes  for selection
      PredictorGenes <- raw_selectionGenes$droso_gene
      
      # for each gene that is the focus of the analysis, change the value 0 for 1
      geneList[PredictorGenes] <- 1
      
      # change the class to factor
      geneList <-  as.factor(geneList)
      
      ## Build the topGO object for biological process ontology
      this_topGOdata <- new("topGOdata",
                            ontology = this_goCategory,
                            allGenes = geneList,
                            geneSel  = PredictorGenes,
                            nodeSize = 5,
                            annot    = annFUN.gene2GO,
                            gene2GO  = gene2go)
      
      # test for enrichment
      # because we coded the genes 1 or 0 for Predictor gene presence or absence,
      # Fisher test (gene count) is probably the best algorithm
      # classic: each GO category is tested independently
      this_topGOresult <- runTest(this_topGOdata,
                                  algorithm = "classic",
                                  statistic = "fisher")
      
      
      
      # create a result table
      # GO Terms identified by fisher test
      myTable <- GenTable(this_topGOdata,
                          pvalue = this_topGOresult,
                          topNodes = length(this_topGOdata@graph@nodes),
                          numChar = 100)
      
      
      # add columns to specify test details
      myTable$species    <- "common to all"
      myTable$goCategory <- this_goCategory
      
      # make a file name
      this_file_name <- paste("result/regression-on-wasp-orthologs/topgo_result",
                              "common-to-all-wasp",
                              this_goCategory,
                              sep = "_")
      # save table
      write.table(x          = myTable,
                  file       = this_file_name,
                  quote      = FALSE,
                  row.names  = FALSE,
                  sep        = "\t")
      
}   
    
    
 


```

## Aim 3: GO Terms associated for each species of bees

```{r aim 3, eval = FALSE, echo = FALSE, include = FALSE}
# obtain GO Terms associated with the predictor genes
# all_predictor_genes_vec
library("biomaRt")
library("topGO")
                     

# vector of all categories available
goCategory_vec <- c("BP", "MF", "CC")

# loop over the species
for(myspecies in bee){
    # loop over the categories
    for(gocat in goCategory_vec){
      
      # set the arguments
      args <- c(myspecies, 
                gocat)
      
      # set experiment details (species, GO Category)
      this_species     <- args[1]
      this_goCategory  <- args[2]
      
      # set species data input
      raw_results_file         <- paste("input/", this_species,
                                        "_5787_gene_orthogroups_list", 
                                        sep = "")
     
      raw_selectionGenes_file  <- paste("result/regression-on-bee-orthologs/",
                                        this_species,
                                        "_bee_regression_predicted_gene_list_tidy", 
                                        sep = "")
      raw_blast_results_file   <- paste("../ortho-enrichment/resultOnScratch/",
                                        this_species,
                                        "_filtered", sep = "")
      hash_table <- paste("../ortho-enrichment/tmp/", this_species,
                          "_protein_gene_hash_table", sep = "")
      
      
      # import all orthogroups
      # columns: orthogroup, gene name
      raw_results <- read.delim(raw_results_file,
                                stringsAsFactors = FALSE, header = FALSE)
      
      # import predictor genes
      # one column with names of orthogroups
      raw_selectionGenes <- read.delim(raw_selectionGenes_file,
                                stringsAsFactors = FALSE, header = FALSE)
      
      
      # blast results: each Drosophila Orthogroup has a match in similarity with a species' protein
      raw_blast_results <- read.table(raw_blast_results_file,
                                      stringsAsFactors = FALSE)
      
      # hash table: protein in column 1, gene in column 2
      hash_df <- read.table(hash_table,
                            stringsAsFactors = FALSE)
      
      # add column names 
      colnames(raw_results) <- c("orthogroup", "gene")
      colnames(raw_selectionGenes) <- "orthogroup"
      colnames(raw_blast_results) <- c("qseqid", "sseqid", "pident", "length",
                                       "mismatch", "gapopen", "qstart",
                                       "qend", "sstart", "send", "evalue",
                                       "bitscore")
      
      colnames(hash_df) <- c("qseqid", "gene")
      
      # add a colum for gene
      raw_selectionGenes$gene <- raw_results$gene[match(raw_selectionGenes$orthogroup,
                                                        raw_results$orthogroup)]
      
      # update blast query sequence id (to gene-LOCXXX, matching DESeq2 result table)
      raw_blast_results$qseqid <- hash_df$gene[match(raw_blast_results$qseqid,
                                                     hash_df$qseqid)]
    
      
      # connect to the genes services
      ensembl <- useEnsembl(biomart = "ensembl",
                            dataset = "dmelanogaster_gene_ensembl")
      
      
      
      # list of droso genes transcript id
      droso_gene_list <- raw_blast_results$sseqid
      
      # obtain GO terms for these genes (they match to our species)
      gene2Go_raw <- getBM(attributes = c("flybase_translation_id", "go_id"), 
                           filters     = "flybase_translation_id", 
                           values      = droso_gene_list, 
                           mart        = ensembl,
                           useCache    = FALSE)
      
      # Remove the genes without GO terms
      gene2Go_df <- subset(x = gene2Go_raw,
                           subset = !go_id == "")
      
      # update the object to fit topgo
      gene_to_go <- aggregate(go_id ~ flybase_translation_id,
                              data = gene2Go_df,
                              c)
      # vector of GO identifiers
      go_id <- gene_to_go$go_id
      
      # add names to the vector
      gene2go <- setNames(go_id,
                          gene_to_go$flybase_translation_id)
      
      ##### GO term enrichment 
      
      # aim to change species's protein names for drosophila names
      # because the TopGO database does not contain non-model data
      # there are NA because blasting droso against the species might have produced no hit
      raw_results$droso_gene <- raw_blast_results$sseqid[match(raw_results$gene,
                                                               raw_blast_results$qseqid)]
      
      raw_selectionGenes$droso_gene <- raw_blast_results$sseqid[match(raw_selectionGenes$gene,
                                                                      raw_blast_results$qseqid)]
      
      
      # remove NA. 
      raw_results <- raw_results[!is.na(raw_results$droso_gene), ]
      raw_selectionGenes <- raw_selectionGenes[!is.na(raw_selectionGenes$droso_gene), ]
      
      
      ## make a vector with 0 or 1 values depending if a gene is predictor or not
      # results: lists of predictor genes 
      geneList <- rep(0, times = length(rownames(raw_results)))
      
      # name each value with the droso genes names
      names(geneList) <- raw_results$droso_gene
      
      # selectionGenes: list of predictor genes  for selection
      PredictorGenes <- raw_selectionGenes$droso_gene
      
      # for each gene that is the focus of the analysis, change the value 0 for 1
      geneList[PredictorGenes] <- 1
      
      # change the class to factor
      geneList <-  as.factor(geneList)
      
      ## Build the topGO object for biological process ontology
      this_topGOdata <- new("topGOdata",
                            ontology = this_goCategory,
                            allGenes = geneList,
                            geneSel  = PredictorGenes,
                            nodeSize = 5,
                            annot    = annFUN.gene2GO,
                            gene2GO  = gene2go)
      
      # test for enrichment
      # because we coded the genes 1 or 0 for Predictor gene presence or absence,
      # Fisher test (gene count) is probably the best algorithm
      # classic: each GO category is tested independently
      this_topGOresult <- runTest(this_topGOdata,
                                  algorithm = "classic",
                                  statistic = "fisher")
      
      
      
      # create a result table
      # GO Terms identified by fisher test
      myTable <- GenTable(this_topGOdata,
                          pvalue = this_topGOresult,
                          topNodes = length(this_topGOdata@graph@nodes),
                          numChar = 100)
      
      
      # add columns to specify test details
      myTable$species    <- this_species
      myTable$goCategory <- this_goCategory
      
      # make a file name
      this_file_name <- paste("result/regression-on-bee-orthologs/topgo_result",
                              this_species,
                              this_goCategory,
                              sep = "_")
      # save table
      write.table(x          = myTable,
                  file       = this_file_name,
                  quote      = FALSE,
                  row.names  = FALSE,
                  sep        = "\t")
      
    }   
    
    
  
}

```

## Aim 4: GO Terms associated for each species of wasps

```{r aim 4, eval = FALSE, echo = FALSE, include = FALSE}
# obtain GO Terms associated with the predictor genes
# all_predictor_genes_vec
library("biomaRt")
library("topGO")
                     

# vector of all categories available
goCategory_vec <- c("BP", "MF", "CC")

# loop over the species
for(myspecies in wasp){
    # loop over the categories
    for(gocat in goCategory_vec){
      
      # set the arguments
      args <- c(myspecies, 
                gocat)
      
      # set experiment details (species, GO Category)
      this_species     <- args[1]
      this_goCategory  <- args[2]
      
      # set species data input
      raw_results_file         <- paste("input/", this_species,
                                        "_6983_gene_orthogroups_list", 
                                        sep = "")
     
      raw_selectionGenes_file  <- paste("result/regression-on-wasp-orthologs/",
                                        this_species,
                                        "_wasp_regression_predicted_gene_list_tidy", 
                                        sep = "")
      raw_blast_results_file   <- paste("../ortho-enrichment/resultOnScratch/",
                                        this_species,
                                        "_filtered", sep = "")
      hash_table <- paste("../ortho-enrichment/tmp/", this_species,
                          "_protein_gene_hash_table", sep = "")
      
      
      # import all orthogroups
      # columns: orthogroup, gene name
      raw_results <- read.delim(raw_results_file,
                                stringsAsFactors = FALSE, header = FALSE)
      
      # import predictor genes
      # one column with names of orthogroups
      raw_selectionGenes <- read.delim(raw_selectionGenes_file,
                                stringsAsFactors = FALSE, header = FALSE)
      
      
      # blast results: each Drosophila Orthogroup has a match in similarity with a species' protein
      raw_blast_results <- read.table(raw_blast_results_file,
                                      stringsAsFactors = FALSE)
      
      # hash table: protein in column 1, gene in column 2
      hash_df <- read.table(hash_table,
                            stringsAsFactors = FALSE)
      
      # add column names 
      colnames(raw_results) <- c("orthogroup", "gene")
      colnames(raw_selectionGenes) <- "orthogroup"
      colnames(raw_blast_results) <- c("qseqid", "sseqid", "pident", "length",
                                       "mismatch", "gapopen", "qstart",
                                       "qend", "sstart", "send", "evalue",
                                       "bitscore")
      
      colnames(hash_df) <- c("qseqid", "gene")
      
      # add a colum for gene
      raw_selectionGenes$gene <- raw_results$gene[match(raw_selectionGenes$orthogroup,
                                                        raw_results$orthogroup)]
      
      # update blast query sequence id (to gene-LOCXXX, matching DESeq2 result table)
      raw_blast_results$qseqid <- hash_df$gene[match(raw_blast_results$qseqid,
                                                     hash_df$qseqid)]
    
      
      # connect to the genes services
      ensembl <- useEnsembl(biomart = "ensembl",
                            dataset = "dmelanogaster_gene_ensembl")
      
      
      
      # list of droso genes transcript id
      droso_gene_list <- raw_blast_results$sseqid
      
      # obtain GO terms for these genes (they match to our species)
      gene2Go_raw <- getBM(attributes = c("flybase_translation_id", "go_id"), 
                           filters     = "flybase_translation_id", 
                           values      = droso_gene_list, 
                           mart        = ensembl,
                           useCache    = FALSE)
      
      # Remove the genes without GO terms
      gene2Go_df <- subset(x = gene2Go_raw,
                           subset = !go_id == "")
      
      # update the object to fit topgo
      gene_to_go <- aggregate(go_id ~ flybase_translation_id,
                              data = gene2Go_df,
                              c)
      # vector of GO identifiers
      go_id <- gene_to_go$go_id
      
      # add names to the vector
      gene2go <- setNames(go_id,
                          gene_to_go$flybase_translation_id)
      
      ##### GO term enrichment 
      
      # aim to change species's protein names for drosophila names
      # because the TopGO database does not contain non-model data
      # there are NA because blasting droso against the species might have produced no hit
      raw_results$droso_gene <- raw_blast_results$sseqid[match(raw_results$gene,
                                                               raw_blast_results$qseqid)]
      
      raw_selectionGenes$droso_gene <- raw_blast_results$sseqid[match(raw_selectionGenes$gene,
                                                                      raw_blast_results$qseqid)]
      
      
      # remove NA. 
      raw_results <- raw_results[!is.na(raw_results$droso_gene), ]
      raw_selectionGenes <- raw_selectionGenes[!is.na(raw_selectionGenes$droso_gene), ]
      
      
      ## make a vector with 0 or 1 values depending if a gene is predictor or not
      # results: lists of predictor genes 
      geneList <- rep(0, times = length(rownames(raw_results)))
      
      # name each value with the droso genes names
      names(geneList) <- raw_results$droso_gene
      
      # selectionGenes: list of predictor genes  for selection
      PredictorGenes <- raw_selectionGenes$droso_gene
      
      # for each gene that is the focus of the analysis, change the value 0 for 1
      geneList[PredictorGenes] <- 1
      
      # change the class to factor
      geneList <-  as.factor(geneList)
      
      ## Build the topGO object for biological process ontology
      this_topGOdata <- new("topGOdata",
                            ontology = this_goCategory,
                            allGenes = geneList,
                            geneSel  = PredictorGenes,
                            nodeSize = 5,
                            annot    = annFUN.gene2GO,
                            gene2GO  = gene2go)
      
      # test for enrichment
      # because we coded the genes 1 or 0 for Predictor gene presence or absence,
      # Fisher test (gene count) is probably the best algorithm
      # classic: each GO category is tested independently
      this_topGOresult <- runTest(this_topGOdata,
                                  algorithm = "classic",
                                  statistic = "fisher")
      
      
      
      # create a result table
      # GO Terms identified by fisher test
      myTable <- GenTable(this_topGOdata,
                          pvalue = this_topGOresult,
                          topNodes = length(this_topGOdata@graph@nodes),
                          numChar = 100)
      
      
      # add columns to specify test details
      myTable$species    <- this_species
      myTable$goCategory <- this_goCategory
      
      # make a file name
      this_file_name <- paste("result/regression-on-wasp-orthologs/topgo_result",
                              this_species,
                              this_goCategory,
                              sep = "_")
      # save table
      write.table(x          = myTable,
                  file       = this_file_name,
                  quote      = FALSE,
                  row.names  = FALSE,
                  sep        = "\t")
      
    }   
    
    
  
}

```

Conclusion

```{r record versions of session, eval = TRUE, echo = FALSE, include = FALSE}
# record versions of R and packages here
sessionInfo()
# R version 3.6.3 (2020-02-29)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Catalina 10.15.4
# 
# Matrix products: default
# BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
# LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
# 
# locale:
# [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8
# 
# attached base packages:
# [1] stats     graphics  grDevices utils     datasets  methods   base     
# 
# other attached packages:
# [1] forcats_0.5.0   stringr_1.4.0   dplyr_0.8.5     purrr_0.3.4     readr_1.3.1    
# [6] tidyr_1.0.3     tibble_3.0.1    tidyverse_1.3.0 ggplot2_3.3.0  
# loaded via a namespace (and not attached):
#  [1] Rcpp_1.0.4.6     cellranger_1.1.0 pillar_1.4.4     compiler_3.6.3   dbplyr_1.4.3    
#  [6] tools_3.6.3      lubridate_1.7.8  jsonlite_1.6.1   lifecycle_0.2.0  gtable_0.3.0    
# [11] nlme_3.1-147     lattice_0.20-41  pkgconfig_2.0.3  rlang_0.4.6      reprex_0.3.0    
# [16] cli_2.0.2        DBI_1.1.0        rstudioapi_0.11  yaml_2.2.1       haven_2.2.0     
# [21] xfun_0.13        xml2_1.3.2       withr_2.2.0      httr_1.4.1       knitr_1.28      
# [26] fs_1.4.1         generics_0.0.2   vctrs_0.3.0      hms_0.5.3        grid_3.6.3      
# [31] tidyselect_1.1.0 glue_1.4.1       R6_2.4.1         fansi_0.4.1      readxl_1.3.1    
# [36] modelr_0.1.7     magrittr_1.5     scales_1.1.1     backports_1.1.7  ellipsis_0.3.0  
# [41] rvest_0.3.5      assertthat_0.2.1 colorspace_1.4-1 stringi_1.4.6    munsell_0.5.0   
# [46] broom_0.5.6      crayon_1.3.4 
```
